#数据安全与性能保障

###持久化选项

#### 简介
    Redis提供两种不同的持久化方法来将数据存储到硬盘里面.
    - 一种方法叫做快照 snapshotting,他可以将存在于某一时刻的所有数据丢写入硬盘里面
    - 另一种方法叫做追加文件 append-only file,他会在执行写命令时,江北执行的写命令复制到硬盘里面.
    可以同时使用也可以单独使用

#### 配置选项

    save 60 1000                           
    stop-writes-on-bgsave-error no
    rdbcompression yes
    dbfilename dump.rdn
    
    appendonly no
    appendfsync everysec
    no-appendfsync-on-rewrite no
    auto-aof-rewrite-percentage 100
    auto-aof-rewrite-min-size 64mb
    
    dir ./
    
#### 快照持久化

    根据配置,快照将被写入dbfilename选项指定的文件里面,并且存储在dir选项指定的路径上面.
    如果在新的快照文件创建完毕之前,Redis 系统 硬件这三者之中的任意一个崩溃了,那么Redis将丢失最近一次创建快照之后写入的数据.  
     
   创建快照的方法有以下几种:
        1.   客户端可以通过Redis 发送**BGSAVE** 命令来创建一个快照.对于支持**BGSAVA**命令的平台来说,Redis会调用***fork***来创建一个子进程,
        然后子进程负责将快照写入硬盘,而父进程则继续处理命令请求.
        2.   客户端还可以通过向Redis 发送**SAVE** 命令来创建一个快照,接到SAVE命令的Redis服务器在快照创建完毕之前将不再响应任何其他命令.
        SAVE 命令并不常用,我们通常只会在没有足够的内存去执行BGSAVE 命令的情况下,又或者即使等待持久化操作执行完毕也无所谓的情况下,才回去使用
        3.  如果用户设置了SAVE 配置选项,比如 save 60 1000,那么从Redis 最近一次创建快照之后开始算起,当"60s 之内有1000次写入" 这个条件满足时,
        Redis就会自动触发 BGSAVE 命令.如果用户设置了多个save 配置选项,那么任意一个save配置选项所设置的条件被满足时,Redis就会触发一次**BGSAVE**.
        4.  当Redis通过**SHUTDOWN** 命令接受到关闭服务器的请求时,或者接收到标准TREM 信号时,会执行一个SAVE命令,阻塞所有客户端,不在执行客户端发送的任何
        命令,并在**SAVE**命令执行完毕之后关闭服务器.
        5.  当一个Redis服务器连接另一个Redis服务器,并向对方发送SYNC命令来开始一次复制操作的时候,如果主服务器目前没有在执行BGSAVE操作,或者主服务器
        并非刚刚执行完**BGSAVE**操作,那么主服务器就会执行**BGSAVE**命令.
    
   
    一定要记住:如果系统真的发生崩溃,用户丢失最近一次生成的快照之后更改的所有数据.因此快照持久化只适用于那些及时丢失一部分数据也不会造成任何问题
    的应用程序,而不能接受这种数据损失的应用程序则可以考虑AOF

   - 个人开发
  _**save 900 1**_ 如果服务器距离上一次成功生成快照已经超过*15min*,并且期间至少执行过一次写操作,那么Redis就会自动开始一次**BGSAVE**操作
     
   ```把开发环境设置的尽量贴近生产环境,有助于判断快照是否生成的过于频繁或者过于稀少```

   - 对日志进行聚合计算
   对日志的处理唯一需要考虑的是:如果Redis崩溃而未能成功创建快照,那么我们能够承受丢失多长时间以内产生的新数据.如果丢失一个小时之内产生的数据可以被接受
   那么可以设置为 _**save 3600 1**_.
   进行数据修复时,首先要弄清楚丢失了哪些数据.我们需要在处理日志的同时记录被处理日志的相关信息. Redis连接 日志文件路径 待处理日志文件中的各个行的回调函数
   
   - 大数据
   为了防止因为**BGSAVE** 进程对内存占用导致的系统停顿,可以关闭自动保存,手动发送**BGSAVE** 或者 **SAVE** ,虽然**BGSAVE**任然会照成停顿,但是能够控制出现的时间.另一方面
   SAVA 会一直阻塞Redis知道快照结束,但是因为他并不创建子进程,所以不会像**BGSAVE** 一样因为创建子进程而导致Redis停顿.因为没有子进程在争抢资源,所以SVAE创建
   快照会比BGSAVE 创建快照的速度要快一些.
    
        
#### AOF

    各种意义来讲AOF可以将,可能出现的数据丢失控制在1s之内,但是随着时间的推移,AOF文件的体积会越来越大甚至可能会用完硬盘空使间.还有一个问题就是,因为Redis在重启
    之后需要重新执行AOF文件记录的所有写命令来还原数据集,所以如果AOF文件体积非常大,那么还原操作执行的时间就可能非常长.
    
    
    为了解决AOF文件体积不断增大的问题,用户可以向Redis发送BGREWRITEAOF命令,这个命令会通过移除AOF文件中的冗余命令来重写AOF文件,使AOF文件的体积变得尽可能的小.
    BGREWRITEAOF 的工作原理和 BGSAVE非常的类似:Redis会创建一个子进程,然后由子进程负责对AOF文件进行重写.所以会存在创建子进程而导致性能问题和内存占用的问题.
    更糟糕的是,如果不加以控制,AOF文件的提酒可能回避快照文件的体积大好几倍,在进行AOF重写和删除旧AOF文件的时候,删除一个体积数十GB的旧AOF文件可能会导致操作系统
    挂起数秒.
    
    
### 复制(主从服务器,读写分离)